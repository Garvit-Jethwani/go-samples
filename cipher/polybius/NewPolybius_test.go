// ********RoostGPT********
/*
Test generated by RoostGPT for test turbo-latest using AI Type Open AI and AI Model gpt-4-turbo

ROOST_METHOD_HASH=NewPolybius_16f47ff92e
ROOST_METHOD_SIG_HASH=NewPolybius_49c3556fdf

================================VULNERABILITIES================================
Vulnerability: CWE-20: Improper Input Validation
Issue: The function does not validate the 'key' parameter for non-latin characters or other invalid input types which could lead to unexpected behavior or errors in cryptographic operations.
Solution: Add validation in the 'NewPolybius' function to ensure that 'key' contains only valid characters. Use a regular expression to enforce this rule.

Vulnerability: CWE-129: Improper Validation of Array Index
Issue: The loop checking for duplicate characters in 'chars' does not properly handle the boundary condition, potentially leading to an out-of-bounds panic when 'i+1' equals the length of 'chars'.
Solution: Modify the loop to ensure 'i+1' does not exceed the length of 'chars'. Use 'i < len(chars)-1' as the loop condition.

Vulnerability: CWE-754: Improper Check for Unusual or Exceptional Conditions
Issue: The function assumes that the size is always perfect square of the length of 'key' without considering other cryptographic requirements or error conditions in key-size relationship.
Solution: Implement additional checks to validate that the key's length meets specific cryptographic standards and conditions beyond just matching the square of 'size'.

Vulnerability: CWE-20: Improper Input Validation
Issue: The function does not check if 'size' is zero, which would lead to a division by zero error in cryptographic calculations if used elsewhere.
Solution: Add a check to return an error if 'size' is zero, preventing further processing and potential runtime panics.

================================================================================
### Scenario 1: Valid Input
Details:
  Description: Tests if the function correctly creates a `Polybius` instance with valid input parameters.
Execution:
  Arrange: Provide a key of length equal to `size` squared and a character string of length at least `size`, containing unique Latin characters.
  Act: Call `NewPolybius` with these parameters.
  Assert: Check that the returned structure matches expected values and no error is returned.
Validation:
  Assert that the returned `Polybius` struct is not nil and has properties set as provided. This test confirms that the function handles valid inputs correctly and initializes the struct as expected, which is crucial for the correct functioning of the rest of the system relying on this module.

### Scenario 2: Negative Size
Details:
  Description: Checks how the function handles a negative size parameter.
Execution:
  Arrange: Provide a negative size value.
  Act: Call `NewPolybius` with this negative size.
  Assert: Expect an error indicating that the size cannot be negative.
Validation:
  Assert that the function returns an error when provided with a negative size. This test ensures that the function enforces the constraint that size must be non-negative, which is important for avoiding logic errors in size-related operations later in the program.

### Scenario 3: Size Exceeds Character Length
Details:
  Description: Ensures the function correctly handles cases where `size` is greater than the length of the `chars` string.
Execution:
  Arrange: Provide a `size` that is greater than the length of `chars`.
  Act: Call `NewPolybius` with these parameters.
  Assert: Expect an error stating that the size is too small to use to slice the provided string.
Validation:
  Confirm that an error is returned under these conditions. This test verifies that the function protects against incorrect slicing of the characters string, which could lead to runtime errors or incorrect behavior.

### Scenario 4: Characters Contain Non-Latin Characters
Details:
  Description: Tests the function's response to input `chars` containing non-Latin characters.
Execution:
  Arrange: Include non-Latin characters in the `chars` string.
  Act: Call `NewPolybius` with this string.
  Assert: Expect an error stating that the string should only contain Latin characters.
Validation:
  Check for an error to ensure that the function correctly validates character constraints, maintaining the integrity of the character data expected by the system.

### Scenario 5: Characters Contain Duplicate Characters
Details:
  Description: Checks the function's handling of duplicate characters within the allowed size in the `chars` string.
Execution:
  Arrange: Provide a `chars` string with duplicate characters within the first `size` characters.
  Act: Call `NewPolybius` with this string.
  Assert: Expect an error stating that the string contains duplicate characters.
Validation:
  Validate that an error is returned, confirming that the function properly enforces character uniqueness within the specified size. This is critical for the correct operation of the cipher, assuming uniqueness is a requirement.

### Scenario 6: Key Length Mismatch
Details:
  Description: Verifies that the function checks for the key length to be exactly `size` squared.
Execution:
  Arrange: Provide a key whose length is not equal to `size` squared.
  Act: Call `NewPolybius` with this key.
  Assert: Expect an error indicating that the key length must match `size` squared.
Validation:
  Ensure an error is returned to confirm that the function enforces the correct relationship between key length and size. This test is essential for the integrity of encryption or decryption processes relying on this relationship.
*/

// ********RoostGPT********
package polybius

import (
	"strings"
	"testing"
)

// TestNewPolybius tests various scenarios for creating a Polybius instance.
func TestNewPolybius(t *testing.T) {
	tests := []struct {
		name       string
		key        string
		size       int
		chars      string
		wantError  bool
		errorMsg   string
	}{
		{
			name:      "Valid Input",
			key:       "ABCDEFGHI",
			size:      3,
			chars:     "abcdefghi",
			wantError: false,
		},
		{
			name:      "Negative Size",
			key:       "ABC",
			size:      -1,
			chars:     "abc",
			wantError: true,
			errorMsg:  "provided size -1 cannot be negative",
		},
		{
			name:      "Size Exceeds Character Length",
			key:       "ABC",
			size:      4,
			chars:     "abc",
			wantError: true,
			errorMsg:  "provided size 4 is too small to use to slice string \"abc\" of len 3",
		},
		{
			name:      "Characters Contain Non-Latin Characters",
			key:       "ABCDEFGHI",
			size:      3,
			chars:     "abc$efghi",
			wantError: true,
			errorMsg:  "provided string \"abc$efghi\" should only contain latin characters",
		},
		{
			name:      "Characters Contain Duplicate Characters",
			key:       "ABCDEFGHI",
			size:      3,
			chars:     "abcaefghi",
			wantError: true,
			errorMsg:  "abcaefghi contains same character 'A'",
		},
		{
			name:      "Key Length Mismatch",
			key:       "ABCDEF",
			size:      3,
			chars:     "abcdefghi",
			wantError: true,
			errorMsg:  "len(key): 6 must be as long as size squared: 9",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Log("Testing:", tt.name)
			result, err := NewPolybius(tt.key, tt.size, tt.chars)
			if (err != nil) != tt.wantError {
				t.Fatalf("Expected error: %v, got: %v", tt.wantError, err)
			}
			if err != nil && !strings.Contains(err.Error(), tt.errorMsg) {
				t.Fatalf("Expected error message '%s', got '%s'", tt.errorMsg, err.Error())
			}
			if err == nil {
				if result.size != tt.size || result.characters != strings.ToUpper(tt.chars[:tt.size]) || result.key != strings.ToUpper(tt.key) {
					t.Errorf("Misconfigured Polybius struct: got %+v", result)
				} else {
					t.Log("Success: Correct instance created")
				}
			} else {
				t.Log("Success: Correct error returned -", err)
			}
		})
	}
}
